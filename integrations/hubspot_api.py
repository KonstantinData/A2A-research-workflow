# integrations/hubspot_api.py
"""Minimal HubSpot CRM integration (best-effort)."""
from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict, List, Optional

import json
import requests

# The static company data is used as a lightweight substitute for a real
# CRM or HubSpot look‑up.  In the live system these helpers would
# perform authenticated API calls to HubSpot to locate companies by
# domain or name, retrieve associated reports and discover similar
# organisations.  For the purposes of unit testing and running the
# full workflow without external connectivity the functions below
# consult the in‑memory dataset defined in ``agents/company_data``.
try:
    # Import at runtime to avoid circular dependencies when this module
    # is imported during testing.  The import may fail if the agents
    # package is not available; in that case the helper functions
    # simply return None or empty lists.
    from agents.company_data import lookup_company, all_company_names, CompanyInfo  # type: ignore
except Exception:
    lookup_company = None  # type: ignore
    all_company_names = lambda: []  # type: ignore
    CompanyInfo = None  # type: ignore


def _token() -> Optional[str]:
    return os.getenv("HUBSPOT_ACCESS_TOKEN")


def upsert_company(data: Dict[str, Any]) -> Optional[str]:
    """
    Create or update a company in HubSpot (best‑effort).

    This helper accepts either a consolidated payload dictionary or a two‑layer
    structure with ``core`` and optional ``hubspot`` sections.  The core
    portion is mapped onto HubSpot CRM properties using a predefined
    mapping (see ``docs/hubspot_mapping.md``).  Additional HubSpot‑specific
    properties may be supplied via the ``hubspot`` key and are passed
    through verbatim.  If no HubSpot access token is configured via
    ``HUBSPOT_ACCESS_TOKEN`` then the function silently returns ``None``.

    Parameters
    ----------
    data: Dict[str, Any]
        The consolidated data to upsert.  It may contain top‑level
        fields conforming to the core schema or a nested ``core`` and
        ``hubspot`` structure.

    Returns
    -------
    Optional[str]
        The HubSpot company ID if available; otherwise ``None``.  The
        static helper returns ``None`` because the implementation does
        not persist data.
    """
    token = _token()
    if not token:
        # No token provided – skip silently.
        return None

    if not isinstance(data, dict):
        return None
    # Determine core and hubspot sections.  When callers pass a flat
    # consolidated dictionary we treat it as the core payload.  Known
    # meta fields are excluded from the core payload.  The optional
    # ``hubspot`` section carries HubSpot‑specific fields (e.g. city,
    # postal_code, etc.).
    if "core" in data:
        core_data: Dict[str, Any] = data.get("core") or {}
        hub_data: Dict[str, Any] = data.get("hubspot") or {}
    else:
        # Exclude meta information from the flat structure
        reserved = {"meta", "classification", "creator", "recipient", "payload"}
        core_data = {k: v for k, v in data.items() if k not in reserved}
        hub_data = {}

    # Build the properties payload according to mapping.  Unknown keys
    # are ignored to avoid uploading arbitrary data to HubSpot.  See
    # docs/hubspot_mapping.md for details.
    props: Dict[str, Any] = {}
    # Core → HubSpot mapping
    if core_data.get("company_name"):
        props["name"] = core_data["company_name"]
    # Domain (use company_domain_name to mirror HubSpot naming); also
    # accept 'company_domain' for backwards compatibility
    domain = core_data.get("domain") or core_data.get("company_domain")
    if domain:
        props["company_domain_name"] = domain
    # Industry grouping
    if core_data.get("industry_group"):
        props["industry_group"] = core_data["industry_group"]
    if core_data.get("industry"):
        props["industry"] = core_data["industry"]
    if core_data.get("description"):
        props["description"] = core_data["description"]
    if core_data.get("country"):
        props["country"] = core_data["country"]

    # Automatically derive company_keywords if not supplied explicitly.  A
    # maximum of ten keywords is generated by splitting the industry and
    # description strings into lower‑cased tokens and removing
    # duplicates.  If the caller provided ``company_keywords`` in the
    # ``hubspot`` section we honour that value instead.
    if "company_keywords" not in hub_data:
        keywords: List[str] = []
        if isinstance(core_data.get("industry"), str):
            keywords.extend(core_data["industry"].lower().split())
        if isinstance(core_data.get("description"), str):
            keywords.extend(core_data["description"].lower().split())
        if keywords:
            # Deduplicate while preserving order
            deduped: List[str] = []
            for kw in keywords:
                if kw and kw not in deduped:
                    deduped.append(kw)
            props["company_keywords"] = deduped[:10]
    # Merge any explicitly provided HubSpot properties.  We only accept
    # scalar values (str, int, float, bool) or lists of strings; other
    # types are ignored to prevent structured data from leaking into
    # HubSpot unintentionally.
    for key, value in hub_data.items():
        if value is None:
            continue
        if isinstance(value, (str, int, float, bool)):
            props[key] = value
        elif isinstance(value, list) and all(isinstance(x, str) for x in value):
            props[key] = value

    # Send the upsert request.  In this environment we do not persist
    # anything and therefore cannot return a real company identifier.  In
    # a production implementation the API response would include the
    # company ID which should be returned to callers.
    url = "https://api.hubapi.com/crm/v3/objects/companies"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
    }
    body = {"properties": props}
    try:
        response = requests.post(url, headers=headers, data=json.dumps(body), timeout=10)
        response.raise_for_status()
        # The HubSpot API returns the new company object.  Extract the
        # ``id`` if present and return it.  When running offline the
        # response will be ignored.
        json_resp = response.json()
        return json_resp.get("id")
    except Exception:
        # Do not fail the pipeline on HubSpot errors; return None
        return None


def check_existing_report(company_id: str) -> Optional[Dict[str, Any]]:
    """Return latest report (id, name, createdAt) for ``company_id`` if present."""
    token = _token()
    if not token:
        return None

    url = "https://api.hubapi.com/files/v3/files/search"
    headers = {"Authorization": f"Bearer {token}"}
    payload = {
        "filters": [
            {"propertyName": "name", "operator": "CONTAINS_TOKEN", "value": "report"},
            {"propertyName": "companyId", "operator": "EQ", "value": company_id},
        ],
        "limit": 1,
        "sorts": ["-createdAt"],
    }
    resp = requests.post(url, headers=headers, json=payload, timeout=30)
    resp.raise_for_status()
    results = resp.json().get("results", [])
    return results[0] if results else None


def attach_pdf(path: Path, company_id: str) -> Dict[str, str]:
    """Upload ``path`` to HubSpot and associate with a company."""
    token = _token()
    portal_id = os.getenv("HUBSPOT_PORTAL_ID")
    if not token or not portal_id:
        raise RuntimeError("missing HubSpot credentials")

    headers = {"Authorization": f"Bearer {token}"}
    upload_url = "https://api.hubapi.com/files/v3/files"
    data = {"options": json.dumps({"access": "PRIVATE"})}
    with path.open("rb") as fh:
        files = {"file": (path.name, fh, "application/pdf")}
        resp = requests.post(upload_url, headers=headers, files=files, data=data, timeout=10)
    resp.raise_for_status()
    file_id = resp.json().get("id")

    assoc_url = (
        f"https://api.hubapi.com/crm/v3/objects/companies/{company_id}/associations/files/{file_id}"
    )
    assoc_payload = {"associationCategory": "HUBSPOT_DEFINED", "associationTypeId": 112}
    resp2 = requests.put(assoc_url, headers=headers, json=assoc_payload, timeout=10)
    resp2.raise_for_status()
    assoc_id = resp2.json().get("id", "")

    return {"file_id": file_id, "association_id": assoc_id}


# --- Static lookup helpers -------------------------------------------------

def _build_company_record(info: "CompanyInfo", *, domain_only: bool = False) -> Dict[str, Any]:
    """Return a simplified HubSpot company record for a given CompanyInfo.

    Parameters
    ----------
    info: CompanyInfo
        The static company information to convert.
    domain_only: bool, default False
        When True only return the record if the caller supplied a
        matching domain.  When False the record is always returned.

    Returns
    -------
    Dict[str, Any]
        A dictionary emulating the shape of HubSpot's company object.
    """
    # Use a synthetic ID to mimic HubSpot's internal identifier.  In a
    # real implementation the ID would be returned by the API.
    record_id = f"static-{info.company_domain}"
    props = {
        "name": info.company_name,
        "domain": info.company_domain,
    }
    # Include an updatedAt timestamp to aid sorting by recency.  When
    # working offline we cannot know when the data was last updated, so
    # omit the field.  Tests that sort by updatedAt should handle
    # missing values gracefully.
    record: Dict[str, Any] = {
        "id": record_id,
        "properties": props,
    }
    return record


def find_company_by_domain(domain: str) -> Optional[Dict[str, Any]]:
    """Return a HubSpot‑like company record matching ``domain``.

    The lookup uses the in‑memory static dataset defined in
    :mod:`agents.company_data`.  If no match is found or the data
    module is unavailable the function returns ``None``.

    Parameters
    ----------
    domain: str
        The domain to search for.  Comparison is case insensitive.

    Returns
    -------
    Optional[Dict[str, Any]]
        A dictionary containing ``id`` and ``properties`` keys if a
        match is found, otherwise ``None``.
    """
    if not domain:
        return None
    if lookup_company is None:
        return None
    # Iterate over all companies and compare the domain case
    # insensitively.  We avoid building the entire dataset into a
    # mapping keyed by domain to keep the static helper simple.
    for name in all_company_names():
        ci = lookup_company(name)
        if ci and ci.company_domain.lower() == domain.strip().lower():
            return _build_company_record(ci)
    return None


def find_company_by_name(name: str) -> List[Dict[str, Any]]:
    """Return a list of possible company matches for ``name``.

    The static dataset is searched for a case insensitive match on the
    company name.  If a match is found it is returned as a single
    element list; otherwise an empty list is returned.  In a real
    implementation this function would call the HubSpot search API.

    Parameters
    ----------
    name: str
        The company name to search for.  Comparison is case insensitive.

    Returns
    -------
    List[Dict[str, Any]]
        A list of dictionaries each representing a possible match.
    """
    if not name:
        return []
    if lookup_company is None:
        return []
    ci = lookup_company(name)
    if not ci:
        return []
    # Return a single match with an updatedAt field to satisfy sorting.
    record = _build_company_record(ci)
    # Add a dummy updatedAt timestamp; using the epoch ensures older
    # records sort before newer ones when combined with other data.
    record["updatedAt"] = "1970-01-01T00:00:00Z"
    return [record]


def list_company_reports(company_id: str) -> List[Dict[str, Any]]:
    """Return a list of previously generated reports for ``company_id``.

    Since this environment does not persist real HubSpot attachments,
    this helper returns an empty list.  In a production system the
    implementation would call ``GET /crm/v3/objects/companies/{companyId}/associations/files``
    or similar to list associated files.

    Parameters
    ----------
    company_id: str
        The identifier of the company whose reports should be listed.

    Returns
    -------
    List[Dict[str, Any]]
        A list of dictionaries describing each report.  Each element
        may contain keys such as ``id``, ``reportDate`` and
        ``createdAt``.  An empty list indicates no previous reports.
    """
    # Without a backend service we cannot know if a company has any
    # existing reports, so return an empty list.  The internal company
    # research will interpret this as no reports and therefore avoid
    # caching outdated results.
    return []


def find_similar_companies(
    industry_group: Optional[str], industry: Optional[str], description: Optional[str]
) -> List[Dict[str, Any]]:
    """Suggest companies with similar characteristics.

    This helper scans the static dataset for companies that share the
    same industry group or industry.  Classification numbers are
    no longer used as primary matching criteria.  If no criteria are
    provided an empty list is returned.  Each suggestion includes
    ``company_name``, ``company_domain``, ``industry_group``, ``industry``,
    ``description`` (copied from the static dataset) and a confidence score.
    The score is a simple heuristic based on how many attributes match; it
    ranges from 0.0 to 1.0.

    Parameters
    ----------
    industry_group: Optional[str]
        The high level industry group to match against.
    industry: Optional[str]
        The specific industry description to match against.
    description: Optional[str]
        A free text description (unused in this static implementation).

    Returns
    -------
    List[Dict[str, Any]]
        A list of candidate companies with associated data and confidence
        scores.  An empty list is returned if no criteria are provided
        or if the static dataset is unavailable.
    """
    if lookup_company is None:
        return []
    if not (industry_group or industry or description):
        return []
    suggestions: List[Dict[str, Any]] = []
    for name in all_company_names():
        ci = lookup_company(name)
        if not ci:
            continue
        matches = 0
        total = 0
        # Compare industry group if provided
        if industry_group:
            total += 1
            if ci.industry_group.lower() == industry_group.lower():
                matches += 1
        # Compare industry if provided
        if industry:
            total += 1
            if ci.industry.lower() == industry.lower():
                matches += 1
        # Description could be compared via text similarity; omitted here
        if total == 0:
            continue
        confidence = matches / total if total else 0.0
        suggestions.append(
            {
                "company_name": ci.company_name,
                "company_domain": ci.company_domain,
                "industry_group": ci.industry_group,
                "industry": ci.industry,
                "description": ci.description,
                "confidence": confidence,
            }
        )
    return suggestions
